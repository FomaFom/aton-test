# Eats



- Допустим, для написания сервиса была выбрана Java.
- Допустим, что используется наиболее популярная 64-разрядная ОС.
- Допустим, что JVM запущена без дополнительных параметров.
- Допустим, длинна телефонного номера в базе данных составляет в средним 18 цифр (с международными кодами).
- Допустим, что для упрощения подсчета полные имена пользователей будут уникальны и по этому не будут попадать в пул строк.
- Допустим, что мы используем Java 11

## Поиск за постоянное время - O(1)

Для достижения среднего времени поиска, равного O(1) нам потребуется использовать структуру данных `HashMap`.

- Сама структура со своими полями займет:  
**16 байт** заголовок класса  
**4 байта** поле `transient int size` 
**4 байта** поле `int threshold`  
**4 байта** `final float loadFactor`  
**8 байт** ссылка на `transient Set< Map.Entry< K,V>> entrySet`  
**8 байт** ссылка на хеш-таблицу `transient Node < K, V> [] table`  
16+4+4+4+8+8=44 байт  
Т.к. необходимо, чтобы все объекты были кратны 8, то выходит **48 байт**.  

  Для понимая примерного количества памяти, необходимого для хранения - нам понадобиться вычислить размер одной ячейки массива.  
  Мы будем импользовать обычный конструктор `new HashMap<>()` без дополнительных параметров, чтобы сохранить скорость поиска.  
  Если же количество свободных корзин ограничить количеством записей, то количество коллизий значительно возрастет, что не даст нам заявить срденюю скорость в O(1).  
  В качестве пары ключ-значение мы будем  использовать `Long` для ключа и `String` для значения.  
  Использование `Long` вместо `String` для хранения телефона позволит уменьшить кол-во памяти:  


- Размер `Long` для номера:  
**16 байт** Заголовок  
**8 байт** `private final long value`;  
8+16 = **24 байта**  
  
  
- Размер String для имени:  
**16 байт** Заголовок  
**1 байт** private final byte coder  
**4 байта** private int hash  
**8 байт** ссылка на private final byte[] value  
**16 байт** заголовок массива  
**4 байта** на хранение длинны массива  
**20 байт** на саму строку т.к. мы предположили длинну имени в 20 символов    
16+1+4+8+16+4+20=69 байт  
Т.к. объекты должны быть кратны 8, то получаем **72 байта**.  
  
  
- Ячейка узла со своими полями займет:  
**16 байт** заголовок класса  
**8 байт** `Node < K, V>` ссылка на следующий узел  
**4 байта** `final int hash`  
**8 байт** ссылка на `final Long key`  
**8 байт** ссылка на `String value`  
16+8+4+8+8 = 44 байта  
Т.к. объекты должны быть кратны 8, то получаем **48 байт**.  
  
  
Количество записей 18 758 328.  
  Количество нод 33 554 432. Такое количество берется от того, что количество таблиц при достижении 75% от максимального количества увеличивается в 2 раза.  
  После нескольких таких итераций при заполнении таблицы мы доберемся до 33 554 432 нод.  
Т.е. кол-во байт = 33 554 432 * 48 = **1 610 612 736 байт**  
Все номера телефонов = 18 758 328 * 24 = **450 199 872 байт**  
Все полные имена = 18 758 328 * 72 = **1 350 599 616 байт**  
Структура, как мы выяснили ранее = **48 байт**  
  
Итого: 1 610 612 736 + 450 199 872 + 1 350 599 616 + 48 = **3 411 412 272 байт**  
**3331458 кБ  
3254 МБ  
3.18 ГБ**  


## Если мы хотим занять как можно меньше памяти

  Для использования минимального количества памяти предлагаю использовать обычный массив, т.к. он имеет минимальные накладные расходы памяти на хранение одной единицы данных  
  Так же в условии не предполагается добавление новых данных и их начальный размер предопределен, следовательно наша структура данных не будет расширятся.  
  Это делает использование массива еще более актуальным.  

  Использование двумерного массива лишено смысла, т.к это все равно будет объект, который может быть даже больше, чем обычный объект, содержащий данные, т.к. в массиве еще хранится количество его элементов.  
Что дает:   
8+4+8+8+16 = 44  
Т.к. объекты должны быть кратны 8, то получаем 48 байт.  
48 восемь байт для вложенного массива куда больше, чем если мы создадим обычный объект.  
  
- Создадим объект, в котором у нас будут 2 поля
`long` как номер телефона  
`String` как полное имя  
В итоге размер такого объекта будет равен:  
**16 байт** Заголовок  
**8 байт** ссылка на строку  
**8 байт** байт `long`  
16+8+8 = **32 байта**  

- Сам массив объектов займет:  
**16 байт** Заголовок  
**4 байта** `int` количества элементов  
18 758 328 * 8 = 150 066 624 байт ссылки на объекты массива  
16+4+150 066 624 = 150 066 644 байт  
Т.к. объекты должны быть кратны 8, то получаем **150 066 648 байт**.  
  
- Итого всего мы тратим:
150 066 648 байт на массив  
32 * 18 758 328 = 600 266 496 байт на все объекты  
  
150 066 648 + 600 266 496 = **750 333 144 байт**  
**732748 кБ  
715.6 МБ  
0,7 ГБ**  
  
Сложность же поиска будет составлять O(n)  
